# mutuala - subcurrency

# We want to issue a currency that reduces in value as you store it through negative interest.  That negative interest would be stored in a commons account.  It's like the p2p version of a capital tax

# TODO how to handle interest
# TODO what should be the tax percentage?

# the same things goes for transactions - you pay as you use the currency.  However, the more you pay, the more you get to say about what the tax is used for

# TODO what should be the tax percentage?

# each participant can propose a recipient for a payout to be made out of the commons account, others can vote on it by awarding it tax_credits.

# TODO what should be the percentage for a proposal to pass?


shared:
    COMMONS = 42
    ADMIN = 666
    CAPITAL_TAX_PER_DAY = 7305 # 5% per year
    PAYMENT_TAX = 20 # 5%
    MAJORITY_PCT = 67

    ACCOUNT_LIST_OFFSET = 2^160
    ACCOUNT_MAP_OFFSET = 2^161
    PROPOSAL_OFFSET = 2^162

init:
    contract.storage[ADMIN] = msg.sender
    contract.storage[ACCOUNT_LIST_OFFSET - 1] = 1
    contract.storage[ACCOUNT_LIST_OFFSET] = msg.sender
    contract.storage[ACCOUNT_MAP_OFFSET + msg.sender] = 10^12
    contract.storage[ACCOUNT_MAP_OFFSET + msg.sender + 1] = block.timestamp

# contract.storage[COMMONS] = balance commons

# contract.storage[ACCOUNT_LIST_OFFSET - 1] = number of accounts
# contract.storage[ACCOUNT_LIST_OFFSET + n] = account n

# contract.storage[PROPOSAL_OFFSET - 1] contains the number of proposals
# contract.storage[PROPOSAL_OFFSET + n] = proposal n

# per account

# contract.storage[ACCOUNT_MAP_OFFSET + account] = balance
# contract.storage[ACCOUNT_MAP_OFFSET + account+1] = timestamp_last_transaction
# contract.storage[ACCOUNT_MAP_OFFSET + account+2] = tax_credits

# per proposal

# contract.storage[proposal] = total_vote_credits
# contract.storage[proposal-1] = recipient
# contract.storage[proposal-2] = amount
# contract.storage[proposal-3] = expiration
#
# contract.storage[proposal+1] = voter
# contract.storage[proposal+2] = vote_amount
#
# TODO should have expiration timestamp, after which the tax_credits are refunded
# TODO verify 'account' input to be < 2**160

code:
    if msg.data[0] == "suicide" and msg.sender == contract.storage[ADMIN]:
        suicide(msg.sender)

    elif msg.data[0] == "balance":
        addr = msg.data[1]
        return(contract.storage[ACCOUNT_MAP_OFFSET + addr])

    elif msg.data[0] == "pay":
        from = msg.sender
        fromvalue = contract.storage[ACCOUNT_MAP_OFFSET + from]
        to = msg.data[1]
        if to == 0 or to >= 2^160:
            return([0, "invalid address"], 2)
        value = msg.data[2]
        tax = value / PAYMENT_TAX

        if fromvalue >= value + tax:
            contract.storage[ACCOUNT_MAP_OFFSET + from] = fromvalue - (value + tax)
            contract.storage[ACCOUNT_MAP_OFFSET + to] += value
            # tax
            contract.storage[COMMONS] += tax
            contract.storage[ACCOUNT_MAP_OFFSET + from + 2] += tax

            # check timestamp field to see if target account exists
            if contract.storage[ACCOUNT_MAP_OFFSET + to + 1] == 0:
                # register new account
                nr_accounts = contract.storage[ACCOUNT_LIST_OFFSET - 1]
                contract.storage[ACCOUNT_LIST_OFFSET + nr_accounts] = to
                contract.storage[ACCOUNT_LIST_OFFSET - 1] += 1
                contract.storage[ACCOUNT_MAP_OFFSET + to + 1] = block.timestamp

            return(1)
        else:
            return([0, "insufficient balance"], 2)

    elif msg.data[0] == "tick":
        nr_accounts = contract.storage[ACCOUNT_LIST_OFFSET - 1]
        account_idx = 0
        tax_paid = 0
        # process all accounts and see if they need processing
        while account_idx < nr_accounts:
            cur_account = contract.storage[ACCOUNT_LIST_OFFSET + account_idx]
            last_timestamp = contract.storage[ACCOUNT_MAP_OFFSET + cur_account + 1]
            time_diff = block.timestamp - last_timestamp
            if time_diff >= 86400:
                tax_days = time_diff / 86400
                balance = contract.storage[ACCOUNT_MAP_OFFSET + cur_account]
                tax = tax_days * (balance / CAPITAL_TAX_PER_DAY)
                if tax > 0:
                    # charge capital tax, but give tax credits in return
                    contract.storage[ACCOUNT_MAP_OFFSET + cur_account] -= tax
                    contract.storage[ACCOUNT_MAP_OFFSET + cur_account + 1] += tax_days * 86400
                    contract.storage[ACCOUNT_MAP_OFFSET + cur_account + 2] += tax

                    contract.storage[COMMONS] += tax
                    tax_paid += 1
            account_idx += 1
        return(tax_paid)

    else:
        return([0, "unknown command"], 2)



